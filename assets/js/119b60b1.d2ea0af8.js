"use strict";(self.webpackChunkdocusaurus_docs=self.webpackChunkdocusaurus_docs||[]).push([[773],{9725:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Features/llm-routing","title":"LLMRouting","description":"Overview","source":"@site/docs/Features/llm-routing.md","sourceDirName":"Features","slug":"/Features/llm-routing","permalink":"/LangSwarm/Features/llm-routing","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":64,"frontMatter":{"title":"LLMRouting","sidebar_position":64},"sidebar":"defaultSidebar","previous":{"title":"LLMConsensus","permalink":"/LangSwarm/Features/llm-consensus"},"next":{"title":"LLMVoting","permalink":"/LangSwarm/Features/llm-voting"}}');var i=s(4848),t=s(8453);const o={title:"LLMRouting",sidebar_position:64},l="LLMRouting",d={},c=[{value:"<strong>Overview</strong>",id:"overview",level:2},{value:"<strong>Key Features</strong>",id:"key-features",level:2},{value:"<strong>API Reference</strong>",id:"api-reference",level:2},{value:"<strong>Class: <code>LLMRouting</code></strong>",id:"class-llmrouting",level:3},{value:"<strong>Initialization</strong>",id:"initialization",level:4},{value:"<strong>Methods</strong>",id:"methods",level:3},{value:"<strong><code>run()</code></strong>",id:"run",level:4},{value:"<strong>Routing Options</strong>",id:"routing-options",level:2},{value:"<strong>Examples</strong>",id:"examples",level:2},{value:"<strong>Basic Example</strong>",id:"basic-example",level:3},{value:"<strong>Advanced Example: Dynamic Routing with Prompt Reformulation</strong>",id:"advanced-example-dynamic-routing-with-prompt-reformulation",level:3},{value:"<strong>How It Works</strong>",id:"how-it-works",level:2},{value:"<strong>Best Practices</strong>",id:"best-practices",level:2},{value:"<strong>Use Cases</strong>",id:"use-cases",level:2},{value:"<strong>Key Advantages</strong>",id:"key-advantages",level:2},{value:"<strong>Future Enhancements</strong>",id:"future-enhancements",level:2}];function a(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"llmrouting",children:(0,i.jsx)(n.strong,{children:"LLMRouting"})})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:(0,i.jsx)(n.strong,{children:"Overview"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"LLMRouting"})," class in LangSwarm dynamically routes queries to specific workflows or agents based on predefined routes. It allows users to select different strategies, such as branching, voting, or consensus, for handling a query. This flexibility makes it an excellent tool for managing complex multi-agent workflows and adapting workflows based on the nature of the input."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"key-features",children:(0,i.jsx)(n.strong,{children:"Key Features"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Routing"}),":",(0,i.jsx)(n.br,{}),"\n","Routes queries to specific workflows (e.g., branching, voting, consensus) based on predefined routes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Workflow Flexibility"}),":",(0,i.jsx)(n.br,{}),"\n","Supports different processing strategies tailored to various use cases."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Multi-Agent Support"}),":",(0,i.jsx)(n.br,{}),"\n","Works with LangChain, Hugging Face, OpenAI, or custom agents via the ",(0,i.jsx)(n.code,{children:"AgentWrapper"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LangChain-Compatible"}),":",(0,i.jsx)(n.br,{}),"\n","Easily integrates into LangChain pipelines for seamless workflows."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"api-reference",children:(0,i.jsx)(n.strong,{children:"API Reference"})}),"\n",(0,i.jsx)(n.h3,{id:"class-llmrouting",children:(0,i.jsxs)(n.strong,{children:["Class: ",(0,i.jsx)(n.code,{children:"LLMRouting"})]})}),"\n",(0,i.jsx)(n.p,{children:"Routes queries to predefined workflows dynamically."}),"\n",(0,i.jsx)(n.h4,{id:"initialization",children:(0,i.jsx)(n.strong,{children:"Initialization"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"LLMRouting(route, bots, main_bot, query, remove_chat=False, verbose=False)\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"route"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"int"})}),(0,i.jsxs)(n.td,{children:["The route to be executed (e.g., ",(0,i.jsx)(n.code,{children:"0"})," for regular processing, ",(0,i.jsx)(n.code,{children:"1"})," for branching)."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bots"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"list"})}),(0,i.jsx)(n.td,{children:"A list of agents participating in the workflow."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"main_bot"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"object"})}),(0,i.jsx)(n.td,{children:"The primary agent for fallback or certain workflows."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"query"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"str"})}),(0,i.jsx)(n.td,{children:"The input query to be routed."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"remove_chat"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bool"})}),(0,i.jsxs)(n.td,{children:["If ",(0,i.jsx)(n.code,{children:"True"}),", removes queries from memory after processing. Default is ",(0,i.jsx)(n.code,{children:"False"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"verbose"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"bool"})}),(0,i.jsxs)(n.td,{children:["If ",(0,i.jsx)(n.code,{children:"True"}),", enables detailed logging. Default is ",(0,i.jsx)(n.code,{children:"False"}),"."]})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"methods",children:(0,i.jsx)(n.strong,{children:"Methods"})}),"\n",(0,i.jsx)(n.h4,{id:"run",children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"run()"})})}),"\n",(0,i.jsx)(n.p,{children:"Executes the specified route, processing the query and returning the output."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"str"}),": The response from the selected workflow or agent."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"routing-options",children:(0,i.jsx)(n.strong,{children:"Routing Options"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Route"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"0"})}),(0,i.jsxs)(n.td,{children:["Regular processing by the ",(0,i.jsx)(n.code,{children:"main_bot"}),"."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"1"})}),(0,i.jsx)(n.td,{children:"Branching: Uses multiple agents to generate diverse outputs."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"2"})}),(0,i.jsx)(n.td,{children:"Voting: Selects the best response based on votes from multiple agents."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"3"})}),(0,i.jsx)(n.td,{children:"Prompt Reformulation: Reformulates the query before processing it."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"4"})}),(0,i.jsx)(n.td,{children:"Inline Prompting: Converts remarks into inline prompts before processing."})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"examples",children:(0,i.jsx)(n.strong,{children:"Examples"})}),"\n",(0,i.jsx)(n.h3,{id:"basic-example",children:(0,i.jsx)(n.strong,{children:"Basic Example"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from langswarm.swarm import LLMRouting\nfrom langswarm.wrappers import AgentWrapper\nfrom langchain.llms import OpenAI\n\n# Step 1: Create and wrap agents\nagent1 = AgentWrapper(agent=OpenAI(model="gpt-4"), is_conversational=True)\nagent2 = AgentWrapper(agent=OpenAI(model="gpt-3.5-turbo"), is_conversational=True)\n\n# Step 2: Initialize LLMRouting with the agents\nquery = "How can AI improve healthcare?"\nrouting_swarm = LLMRouting(route=2, bots=[agent1, agent2], main_bot=agent1, query=query, verbose=True)\n\n# Step 3: Run the routing workflow\nresponse = routing_swarm.run()\n\n# Display the results\nprint("Routed Response:", response)\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"advanced-example-dynamic-routing-with-prompt-reformulation",children:(0,i.jsx)(n.strong,{children:"Advanced Example: Dynamic Routing with Prompt Reformulation"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from langswarm.swarm import LLMRouting\nfrom langswarm.wrappers import AgentWrapper\nfrom transformers import pipeline\n\n# Step 1: Create and wrap agents\nhuggingface_agent = AgentWrapper(agent=pipeline("text-generation", model="gpt2"), is_conversational=False)\nopenai_agent = AgentWrapper(agent="openai_gpt3", is_conversational=True)  # Assuming an OpenAI agent wrapper\n\n# Step 2: Initialize LLMRouting with reformulation route\nquery = "Explain how blockchain technology works."\nrouting_swarm = LLMRouting(route=3, bots=[huggingface_agent, openai_agent], main_bot=openai_agent, query=query)\n\n# Step 3: Run the routing workflow\nresponse = routing_swarm.run()\n\n# Display the results\nprint("Reformulated Response:", response)\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"how-it-works",children:(0,i.jsx)(n.strong,{children:"How It Works"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Select Route"}),":",(0,i.jsx)(n.br,{}),"\n","Based on the ",(0,i.jsx)(n.code,{children:"route"})," parameter, LLMRouting determines which workflow to execute."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Process Query"}),":",(0,i.jsx)(n.br,{}),"\n","The query is processed using the selected workflow or agent(s)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Return Response"}),":",(0,i.jsx)(n.br,{}),"\n","The result of the selected workflow is returned to the user."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:(0,i.jsx)(n.strong,{children:"Best Practices"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Choose Routes Strategically"}),":",(0,i.jsx)(n.br,{}),"\n","Select appropriate routes based on the nature of the query and desired output."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Enable Verbose Mode"}),":",(0,i.jsx)(n.br,{}),"\n","Use ",(0,i.jsx)(n.code,{children:"verbose=True"})," during development to understand how queries are routed and processed."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Combine with Other Tools"}),":",(0,i.jsx)(n.br,{}),"\n","Use LLMRouting in conjunction with tools like ",(0,i.jsx)(n.code,{children:"LLMConsensus"})," or ",(0,i.jsx)(n.code,{children:"LLMAggregation"})," for advanced workflows."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"use-cases",children:(0,i.jsx)(n.strong,{children:"Use Cases"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Query Handling"}),":",(0,i.jsx)(n.br,{}),"\n","Route queries to different workflows based on input type or requirements."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Adaptive Workflows"}),":",(0,i.jsx)(n.br,{}),"\n","Adjust workflows dynamically for complex use cases like brainstorming or decision-making."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Query Reformulation"}),":",(0,i.jsx)(n.br,{}),"\n","Improve query clarity and precision with reformulation and inline prompting."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"key-advantages",children:(0,i.jsx)(n.strong,{children:"Key Advantages"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dynamic and Flexible"}),":",(0,i.jsx)(n.br,{}),"\n","Adapts workflows to suit diverse query requirements."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Workflow Integration"}),":",(0,i.jsx)(n.br,{}),"\n","Seamlessly integrates with other LangSwarm tools and LangChain pipelines."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Simplified Multi-Agent Management"}),":",(0,i.jsx)(n.br,{}),"\n","Provides a unified interface for handling multiple workflows."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"future-enhancements",children:(0,i.jsx)(n.strong,{children:"Future Enhancements"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Route Recommendations"}),":",(0,i.jsx)(n.br,{}),"\n","Automatically recommend optimal routes based on query analysis."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Custom Route Logic"}),":",(0,i.jsx)(n.br,{}),"\n","Allow users to define custom routes and workflows."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Advanced Analytics"}),":",(0,i.jsx)(n.br,{}),"\n","Provide detailed analytics on routing decisions and outcomes."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"LLMRouting"})," class is a versatile tool for managing dynamic workflows in multi-agent systems. By enabling flexible routing of queries, LangSwarm ensures adaptability and efficiency in handling diverse AI tasks."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var r=s(6540);const i={},t=r.createContext(i);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);