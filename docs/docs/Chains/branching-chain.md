---
title: BranchingChain
sidebar_position: 31
---

# BranchingChain

---

## **Overview**
The `BranchingChain` class is a custom, LangChain-compatible chain designed to facilitate branching workflows by generating multiple responses from a set of Large Language Model (LLM) agents. It leverages the `LLMBranching` class to explore diverse outputs from different agents for a given query.

This chain is particularly useful in scenarios where multiple perspectives or creative variations are required, making it a valuable component in LangChain pipelines.

---

## **Purpose**
The primary purpose of the `BranchingChain` class is:
- **Generating Multiple Responses**: To enable exploration of diverse outputs from multiple LLM agents for a single input query.
- **Pipeline Integration**: To act as a reusable chain within LangChain workflows, allowing integration with other tools or chains.
- **Flexibility**: To allow customization of the branching process through additional parameters.

---

## **Class Definition**

```python
class BranchingChain(Chain):
    def __init__(self, agents, **kwargs):
        """
        Initializes the BranchingChain.

        Parameters:
        - agents (list): List of agents to use in the branching process.
        - kwargs: Additional parameters for the LLMBranching class.
        """
        self.branching = LLMBranching(clients=agents, **kwargs)

    @property
    def input_keys(self):
        """Define input keys for the chain."""
        return ["query"]

    @property
    def output_keys(self):
        """Define output keys for the chain."""
        return ["responses"]

    def _call(self, inputs):
        """
        Processes the input query and returns a list of responses.

        Parameters:
        - inputs (dict): Dictionary containing the query.

        Returns:
        - dict: Dictionary containing the list of responses.
        """
        query = inputs["query"]
        self.branching.query = query
        responses = self.branching.run()
        return {"responses": responses}
```

---

## **Key Components**

1. **`__init__` Method**
   - Initializes the chain with a list of agents and additional parameters.
   - Creates an instance of the `LLMBranching` class to handle the branching process.
   - Parameters:
     - `agents`: A list of LLM agents used for branching.
     - `kwargs`: Optional parameters passed to configure the `LLMBranching` class.

2. **`input_keys` Property**
   - Specifies the input keys required by the chain.
   - Inputs:
     - `query`: The user query to be processed.

3. **`output_keys` Property**
   - Specifies the output key returned by the chain.
   - Outputs:
     - `responses`: A list of responses generated by the branching process.

4. **`_call` Method**
   - Core logic for executing the chain.
   - Workflow:
     - Accepts a `query` input.
     - Assigns the `query` to the `LLMBranching` instance.
     - Calls the `run` method of `LLMBranching` to generate multiple responses.
     - Returns the responses as a dictionary.

---

## **Usage**

1. **Initialization**
   ```python
   from langswarm.swarm.branching import LLMBranching
   from mymodule import BranchingChain

   # Example list of agents (LLM clients)
   agents = [agent1, agent2, agent3]

   # Initialize the BranchingChain
   chain = BranchingChain(agents=agents, param1=value1, param2=value2)
   ```

2. **Execution**
   ```python
   # Input data
   inputs = {
       "query": "Suggest creative business ideas in the tech industry.",
   }

   # Get the list of responses
   result = chain(inputs)
   print(result["responses"])
   ```

3. **Integration with LangChain Pipelines**
   - The `BranchingChain` can be integrated into LangChain workflows as a standalone chain or in combination with other chains and tools.
   ```python
   from langchain.chains import SequentialChain

   # Example pipeline
   pipeline = SequentialChain(chains=[chain, another_chain])
   pipeline.run(inputs)
   ```

---

## **Customization**
- **Adding Custom Parameters**: Pass additional parameters to `LLMBranching` via the `kwargs` argument during initialization.
- **Extending the Chain**: Subclass `BranchingChain` to modify or extend functionality, such as post-processing the responses.

---

## **Use Cases**
1. **Creative Ideation**:
   - Generate multiple creative solutions or ideas for brainstorming.
2. **Exploring Diverse Perspectives**:
   - Obtain varied viewpoints or responses to open-ended questions.
3. **A/B Testing**:
   - Compare different outputs from multiple agents for evaluation or selection.

---

## **Comparison with Other Chains**
- **BranchingChain**: Generates diverse responses from multiple agents, focusing on exploring possibilities.
- **AggregationChain**: Synthesizes responses into a single, unified result.
- **ConsensusChain**: Builds agreement among agents to determine the most supported response.

---

This documentation provides a detailed explanation of the purpose, structure, and usage of the `BranchingChain` class. Let me know if you'd like further elaboration or enhancements!
